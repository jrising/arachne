**assistant**:
> Below are selected log entries of past conversations, as part of an experimental AI memory system. T
**user**:
> I am using dplyr, and I am having trouble finding the lag of this a column. It shows up as all NAs. Here's my simple repro:
> > subset(pdf, ISO == 'CHN' & mc == 1)
> # A tibble: 3 × 4
> # Groups:   ISO, Year [3]
>   ISO    Year    mc cumul.allcap.usd.nn
>   <chr> <dbl> <int>               <dbl>
> 1 CHN    2021     1              -9620.
> 2 CHN    2022     1             -11109.
> 3 CHN    2023     1             -12822.
> > pdf2 <- pdf %>%
> +     group_by(ISO, Year, mc) %>%
> +     mutate(cumul.allcap.usd.nn.lag=dplyr::lag(cumul.allcap.usd.nn), allcap.usd=cumul.allcap.usd.nn - cumul.allcap.usd.nn.lag)
> > subset(pdf2, ISO == 'CHN' & mc == 1)
> # A tibble: 3 × 6
> # Groups:   ISO, Year, mc [3]
>   ISO    Year    mc cumul.allcap.usd.nn cumul.allcap.usd.nn.lag allcap.usd
>   <chr> <dbl> <int>               <dbl>                   <dbl>      <dbl>
> 1 CHN    2021     1              -9620.                      NA         NA
> 2 CHN    2022     1             -11109.                      NA         NA
> 3 CHN    2023     1             -12822.                      NA         NA
> 
> How can I get NAs, when the underlying data has no NAs?
**assistant**:
> The issue here is that you're grouping by `ISO`, `Year`, and `mc` simultaneously, which means the `lag` function is calculated over groups that contain only one row each. This is why you get `NA` for all `cumul.allcap.usd.nn.lag` values.
> 
> You should omit `Year` from the grouping to ensure that the `lag` function operates within groups that contain multiple rows. Here's the corrected version of your code:
> 
> ```r
> pdf2 <- pdf %>%
>   group_by(ISO, mc) %>%
>   mutate(cumul.allcap.usd.nn.lag = dplyr::lag(cumul.allcap.usd.nn),
>          allcap.usd = cumul.allcap.usd.nn - cumul.allcap.usd.nn.lag) %>%
>   ungroup()
> 
> subset(pdf2, ISO == 'CHN' & mc == 1)
> ```
> 
> By grouping only by `ISO` and `mc`, the `lag` function will properly compute the lagged values. Additionally, don't forget to `ungroup()` to avoid any unwanted residual grouping on the subsequent operations.
> 
> Here's the expected output after this correction:
> 
> ```r
> # A tibble: 3 × 6
>   ISO    Year    mc cumul.allcap.usd.nn cumul.allcap.usd.nn.lag allcap.usd
>   <chr> <dbl> <int>               <dbl>                   <dbl>      <dbl>
> 1 CHN    2021     1              -9620.                      NA         NA
> 2 CHN    2022     1             -11109.                  -9620.     -1489.
> 3 CHN    2023     1             -12822.                 -11109.     -1713.
> ```
