**user**:
> Can you translate the following code from R to Julia:
> ```
> calc.domar.change <- function(TT, labels, isos, dimpact) {
>     ## Match up known impacts to IO countries
>     isos[isos == 'SDN'] <- 'SUD'
>     isos[isos == 'PSX'] <- 'PSE'
>     labels2 <- labels %>% left_join(data.frame(V1=isos, dimpact=dimpact), by='V1')
>     labels2$dimpact[labels2$V1 == 'ANT'] <- labels2$dimpact[labels2$V1 == 'NLD']
> 
>     ## Calculate Domar weights
>     total.sales <- rowSums(TT) + labels2$FD
>     labels2$gdp <- labels2$FD + labels2$VA
>     global.gdp <- sum(labels2$gdp)
>     weights <- total.sales / global.gdp
> 
>     ## Calculate global GDP loss
>     dimpact.level <- exp(labels2$dimpact) - 1
>     total.change <- sum(weights * ifelse(is.na(dimpact.level), 0, dimpact.level))
> 
>     ## Extract out the additional
>     total.trade.effect <- total.change - sum(dimpact.level * labels2$gdp, na.rm=T) / global.gdp
> 
>     total.trade.effect
> }
> 
> calc.domar.distribute.method1 <- function(TT, labels, isos, dimpact) {
>     domar.change <- calc.domar.change(TT, labels, isos, dimpact)
> 
>     ## Distribute domar loss
>     dirimpacts <- data.frame(ISO=isos, dimpact)
>     totimpacts <- data.frame()
>     for (iso in isos) {
>         comtrade.iso <- subset(comtrade, ReporterISO == iso & PartnerISO != 'W00')
>         if (nrow(comtrade.iso) == 0)
>             next
>         results2.iso <- subset(results2, ISO == iso)
> 
>         maxgrow <- max(0, dimpact[isos == iso])
> 
>         calcdf <- comtrade.iso %>% left_join(dirimpacts, by=c('PartnerISO'='ISO'))
> 
>         ## Limit any growth to growth of country
>         calcdf$cif.lost <- calcdf$Cifvalue * pmax(-calcdf$dimpact, -maxgrow)
>         calcdf$fob.lost <- calcdf$Fobvalue * pmax(-calcdf$dimpact, -maxgrow)
> 
>         ## Fill in NAs, with preference based on direction
>         calcdf$fob.lost[is.na(calcdf$fob.lost) & calcdf$FlowDesc == 'Export'] <- calcdf$cif.lost[is.na(calcdf$fob.lost) & calcdf$FlowDesc == 'Export']
>         calcdf$Fobvalue[is.na(calcdf$fob.lost) & calcdf$FlowDesc == 'Export'] <- calcdf$Cifvalue[is.na(calcdf$fob.lost) & calcdf$FlowDesc == 'Export']
>         calcdf$cif.lost[is.na(calcdf$cif.lost) & calcdf$FlowDesc == 'Import'] <- calcdf$fob.lost[is.na(calcdf$cif.lost) & calcdf$FlowDesc == 'Import']
>         calcdf$Cifvalue[is.na(calcdf$cif.lost) & calcdf$FlowDesc == 'Import'] <- calcdf$Fobvalue[is.na(calcdf$cif.lost) & calcdf$FlowDesc == 'Import']
> 
>         fracloss.import <- sum(calcdf$cif.lost[calcdf$FlowDesc == 'Import'], na.rm=T) / sum(calcdf$Cifvalue[calcdf$FlowDesc == 'Import'], na.rm=T)
>         fracloss.export <- sum(calcdf$fob.lost[calcdf$FlowDesc == 'Export'], na.rm=T) / sum(calcdf$Fobvalue[calcdf$FlowDesc == 'Export'], na.rm=T)
> 
>         totimpacts <- rbind(totimpacts, data.frame(ISO=iso, fracloss.import, fracloss.export))
>     }
> 
>     totimpacts2 <- totimpacts %>% left_join(df.gdp3, by=c('ISO'='Country Code'))
> 
>     list(global=data.frame(domar.change, global.gdp=sum(totimpacts2$GDP.2019.est, na.rm=T), global.loss=sum(ifelse(is.na(totimpacts2$fracloss.export), 0, totimpacts2$fracloss.export) * totimpacts2$GDP.2019.est, na.rm=T)),
>          totimpacts2=totimpacts2)
> }
> 
> calc.domar.distribute.method2 <- function(scaleby, isos, totimpacts2) {
>     totimpacts2$tradeloss <- totimpacts2$fracloss.export * scaleby
> 
>     domar.loss2 <- data.frame(ISO=isos) %>% left_join(totimpacts2)
>     domar.loss2$tradeloss
> }
> 
> logscalebys <- c(0)
> for (year in unique(results2$Year)) {
>     results2.year <- subset(results2, Year == year)
>     dimpact <- results2.year$dimpact
> 
>     output <- calc.domar.distribute.method1(year, results2.year$ISO, dimpact)
> 
>     thisglobal <- output$global
>     thisglobal$yy <- thisglobal$domar.change * thisglobal$global.gdp
>     if (thisglobal$yy > 0) {
>         logscaleby <- log(thisglobal$yy) - log(thisglobal$global.loss)
>         if (logscaleby >= 0)
>             logscalebys <- c(logscalebys, logscaleby)
>     }
> 
>     mod <- lm(scalebys ~ 1)
>     smoothscalebys <- exp(predict(mod, data.frame(years=unique(results2$Year)))) * exp(var(mod$resid) / 2)
> 
>     losses <- calc.domar.distribute.method2(smoothscalebys[ii], results2.year$ISO, output$thisyear2)
> 
>     PROCESS_LOSSES(losses)
> }
> ```
**assistant**:
> Translating R code to Julia can be quite involved, especially with data manipulation and statistical modeling work involving libraries such as `dplyr` and `stats` in R. Fortunately, Julia offers powerful libraries, like `DataFrames.jl` for data manipulation and `GLM.jl` for statistical modeling. Here is a rough translation, assuming you're using these libraries:
> 
> ```julia
> using DataFrames
> using Statistics
> using LinearAlgebra
> using GLM
> 
> function calc_domar_change(TT, labels, isos, dimpact)
>     # Match up known impacts to IO countries
>     replace!(isos, "SDN" => "SUD")
>     replace!(isos, "PSX" => "PSE")
>     labels2 = leftjoin(labels, DataFrame(V1=isos, dimpact=dimpact), on=:V1)
>     labels2[labels2.V1 .== "ANT", :dimpact] .= labels2[labels2.V1 .== "NLD", :dimpact]
> 
>     # Calculate Domar weights
>     total_sales = vec(sum(TT, dims=1)) + labels2.FD
>     labels2[!, :gdp] = labels2.FD + labels2.VA
>     global_gdp = sum(labels2.gdp)
>     weights = total_sales / global_gdp
> 
>     # Calculate global GDP loss
>     dimpact_level = exp.(labels2.dimpact) .- 1
>     total_change = sum(weights .* replace(dimpact_level, missing => 0))
> 
>     # Extract out the additional
>     total_trade_effect = total_change - sum(replace(dimpact_level .* labels2.gdp, missing => 0)) / global_gdp
> 
>     return total_trade_effect
> end
> 
> function calc_domar_distribute_method1(TT, labels, isos, dimpact)
>     domar_change = calc_domar_change(TT, labels, isos, dimpact)
> 
>     # Distribute domar loss
>     dirimpacts = DataFrame(ISO=isos, dimpact=dimpact)
>     totimpacts = DataFrame()
> 
>     for iso in isos
>         comtrade_iso = comtrade[comtrade.ReporterISO .== iso .&& comtrade.PartnerISO .!= "W00", :]
>         if nrow(comtrade_iso) == 0
>             continue
>         end
> 
>         results2_iso = results2[results2.ISO .== iso, :]
> 
>         maxgrow = max(0, dimpact[findfirst(isequal.(isos), iso)])
> 
>         calcdf = leftjoin(comtrade_iso, dirimpacts, on=:PartnerISO => :ISO)
> 
>         # Limit any growth to the growth of the country
>         calcdf[!, :cif_lost] = calcdf.Cifvalue .* max.(-calcdf.dimpact, -maxgrow)
>         calcdf[!, :fob_lost] = calcdf.Fobvalue .* max.(-calcdf.dimpact, -maxgrow)
> 
>         # Fill in missing values with preference based on direction
>         calcdf[calcdf.FlowDesc .== "Export", :fob_lost] .= coalesce.(
>             calcdf[calcdf.FlowDesc .== "Export", :fob_lost],
>             calcdf[calcdf.FlowDesc .== "Export", :cif_lost]
>         )
>         calcdf[calcdf.FlowDesc .== "Export", :Fobvalue] .= coalesce.(
>             calcdf[calcdf.FlowDesc .== "Export", :fob_lost],
>             calcdf[calcdf.FlowDesc .== "Export", :Cifvalue]
>         )
>         calcdf[calcdf.FlowDesc .== "Import", :cif_lost] .= coalesce.(
>             calcdf[calcdf.FlowDesc .== "Import", :fob_lost],
>             calcdf[calcdf.FlowDesc .== "Import", :cif_lost]
>         )
>         calcdf[calcdf.FlowDesc .== "Import", :Cifvalue] .= coalesce.(
>             calcdf[calcdf.FlowDesc .== "Import", :fob_lost],
>             calcdf[calcdf.FlowDesc .== "Import", :Fobvalue]
>         )
> 
>         fracloss_import = sum(skipmissing(calcdf[calcdf.FlowDesc .== "Import", :cif_lost])) /
>                         sum(skipmissing(calcdf[calcdf.FlowDesc .== "Import", :Cifvalue]))
>         fracloss_export = sum(skipmissing(calcdf[calcdf.FlowDesc .== "Export", :fob_lost])) /
>                         sum(skipmissing(calcdf[calcdf.FlowDesc .== "Export", :Fobvalue]))
> 
>         append!(totimpacts, DataFrame(ISO=iso, fracloss_import=fracloss_import, fracloss_export=fracloss_export))
>     end
> 
>     totimpacts2 = leftjoin(totimpacts, df_gdp3, on="ISO" => "Country Code")
> 
>     return (
>         global=DataFrame(domar_change=domar_change,
>                          global_gdp=sum(skipmissing(totimpacts2.GDP_2019_est)),
>                          global_loss=sum(replace(totimpacts2.fracloss_export, missing => 0) .* totimpacts2.GDP_2019_est)),
>         totimpacts2=totimpacts2
>     )
> end
> 
> function calc_domar_distribute_method2(scaleby, isos, totimpacts2)
>     totimpacts2[!, :tradeloss] = totimpacts2.fracloss_export .* scaleby
> 
>     domar_loss2 = leftjoin(DataFrame(ISO=isos), totimpacts2)
>     return domar_loss2.tradeloss
> end
> 
> logscalebys = [0.0]
> for year in unique(results2.Year)
>     results2_year = results2[results2.Year .== year, :]
>     dimpact = results2_year.dimpact
> 
>     output = calc_domar_distribute_method1(year, results2_year.ISO, dimpact)
> 
>     thisglobal = output.global
>     thisglobal[!, :yy] = thisglobal.domar_change .* thisglobal.global_gdp
>     if thisglobal.yy > 0
>         logscaleby = log(thisglobal.yy) - log(thisglobal.global_loss)
>         if logscaleby >= 0
>             push!(logscalebys, logscaleby)
>         end
>     end
> 
>     mod = lm(@formula(scalebys ~ 1), DataFrame(scalebys=logscalebys))
>     smoothscalebys = exp.(predict(mod, DataFrame(years=unique(results2.Year)))) .* exp(var(residuals(mod)) / 2)
> 
>     losses = calc_domar_distribute_method2(smoothscalebys[ii], results2_year.ISO, output.totimpacts2)
> 
>     PROCESS_LOSSES(losses)
> end
> ```
> 
> Some considerations and tasks remain:
> 
> 1. Replace `comtrade`, `results2`, and `df.gdp3` with your actual Julia `DataFrame` objects.
> 2. The indexing system in Julia differs slightly from R; care has been taken to adapt this, but please verify for specific cases.
> 3. Make sure `PROCESS_LOSSES` and any calculated variables like `smoothscalebys[ii]` match the intended logic in your environment.
> 4. The statistical modeling using `GLM.jl` assumes the analogous interpretation of R's `lm()`. The translation of formula-based models relies on the `@formula` macro.
> 5. Convert column names with dots such as `GDP.2019.est` to valid Julia `DataFrame` column names, like `GDP_2019_est`.
