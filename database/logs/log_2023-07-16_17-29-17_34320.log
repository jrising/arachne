James wanted to set up his Flask app served under Passenger in a way that it would return immediately while processing continued in the background. Arachne suggested using a task queue such as Celery or RQ to achieve this. The outline for setting up the task queue included installing RQ or Celery, adding tasks to the Flask app, setting up a queue with a backend like Redis, and running workers to process tasks. Arachne emphasized that in a Passenger environment, each process or thread is separate and does not share memory, so shared state needs to be stored in a persistent storage system like a database or Redis. The shared state can be used to communicate progress updates to the client-side JavaScript by updating it at the end of each task and providing an endpoint for JavaScript to poll. Arachne warned against starting long-running tasks directly in Flask and recommended using a task queue for any work that takes more than a few seconds. Finally, Arachne provided documentation links for Celery and RQ for further instructions.
